Revision: 64e8d0566cf5883c350dda9c69b05e4c28582599
Patch-set: 1
File: services/audioflinger/FastMixer.cpp

390:20-390:62
Wed Mar 02 01:41:22 2016 +0000
Author: Andy Hung <1040213@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e27a7932_3f5db8f3
Bytes: 291
I believe this only needs to be cleared if there are no tracks to mix (none are enabled).  We might be able to check this condition on line 412, and if mMixerBufferState is not ZEROED, set mMixerBufferState to UNDEFINED.  That should clear the buffer on line 419.

Glenn would know better...

390:20-390:62
Wed Mar 02 02:40:34 2016 +0000
Author: Glenn Kasten <1004395@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e27a7932_3f5db8f3
UUID: 02986d84_58e34ac2
Bytes: 639
I am away from the full source code at the moment,
so it is difficult for me to review this right now.
However, the intention of mMixerBufferState is to keeo track
of the state of the mix buffer, and to only zero it when necessary.
We definitely would want to keep that optimization to eliminate
unnecessary zero operations. 

Again, I'm not seeing all the code, but it seems like
it would be incorrect to clear the mix buffer for each track.
Is this new code being executed for _every_ track
(that is in underrun)?  And what happens if a previous
track was not in underrun ... would we lose the previously
mixed data? Either would be bad.

390:20-390:62
Wed Mar 02 02:40:34 2016 +0000
Author: Glenn Kasten <1004395@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e27a7932_3f5db8f3
UUID: 42318581_4ce258eb
Bytes: 639
I am away from the full source code at the moment,
so it is difficult for me to review this right now.
However, the intention of mMixerBufferState is to keeo track
of the state of the mix buffer, and to only zero it when necessary.
We definitely would want to keep that optimization to eliminate
unnecessary zero operations. 

Again, I'm not seeing all the code, but it seems like
it would be incorrect to clear the mix buffer for each track.
Is this new code being executed for _every_ track
(that is in underrun)?  And what happens if a previous
track was not in underrun ... would we lose the previously
mixed data? Either would be bad.

390:20-390:62
Wed Mar 02 02:54:37 2016 +0000
Author: Eric Laurent <1003259@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 42318581_4ce258eb
UUID: 02594de9_0e4d4c68
Bytes: 311
If the logic is similar to the normal mixer, then we should clear the mix buffer only if all tracks are underruning because in this case the mixer process function will be a nop.
To answer Glenn's concern this takes place before the actual mixer process() so there is no risk to lose data from a previous track.

390:20-390:62
Wed Mar 02 09:27:34 2016 +0000
Author: Sumit Bhattacharya <1057645@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 02594de9_0e4d4c68
UUID: 42034591_2c96f773
Bytes: 762
As eric mentioned any data loss will not happen in this case because mixer->process() gets called after processing all the tracks. So memset will happen before actual mixing happens.

But yes if there are possibility of unnecessary memset() operations with this change.

Problem is we can't just set mMixerBufferState to UNDEFINED when there is a underrun for a track, since some other track may have ready data.

My suggestion to avoid extra memset is :

=> Add a new MixerBufferState as READY
=> Set mMixerBufferState to UNDEFINED at start of every onWork() loop. Set mMixerBufferState to READY if for any track data is available.
=> Call mixer->process() only if mMixerBufferState is READY.

Let me know how this sounds. If you agree i will update the commit.

