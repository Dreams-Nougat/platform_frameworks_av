Revision: cf0525f2d4c41723efea5745120e38a72a24e4c4
Patch-set: 1
File: media/libstagefright/AwesomePlayer.cpp

2028
Tue Jan 08 09:45:57 2013 +0000
Author: Patrik Carlsson <1017178@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: N556qmXE
Bytes: 362
The Mutex is already unlocked when connection so there seems to be 
no point in adding mConnectingDataSource.disconnect() outside of the mutex
in reset() and it is already present inside of the mutex.

When reset_l() aborts the connection and this function returns an error it
will call abortPrepare that signals the preparedcondition so that reset_l can finish.

2028
Tue Jan 08 10:15:32 2013 +0000
Author: Feng Xiao <1015362@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: N556qmXE
UUID: N4KiVX6I
Bytes: 467
Yes, what you explain is right. But this mConnectingDataSource.disconnect() is not just for interrupt  mConnectingDataSource->connect(mUri, &mUriHeaders), also for other things.  For example, requesting enough data to establish extractor or meta data and so on, when these are blocked, other calling cannot acquire the lock. So add another way to interrupt from the "mConnectingDataSource" , make the blocking calls return err and other calling can  acquire the lock.

2028
Tue Jan 08 10:30:38 2013 +0000
Author: Patrik Carlsson <1017178@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: N4KiVX6I
UUID: N574q9ec
Bytes: 163
OK, by not clearing mConnectingDataSource after its use you are keeping a reference to the internal http source of NuCachedSource and can interrupt it at any time.

2028
Tue Jan 08 12:03:44 2013 +0000
Author: Patrik Carlsson <1017178@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: N574q9ec
UUID: N536s7TY
Bytes: 226
Though NuCachedsource will not return an error on disconnect,
it will try to reconnect first and any read blocking from within a mutex in awesomeplayer will only get released once it is ready.

See NuCachedSource::ReadInternal

